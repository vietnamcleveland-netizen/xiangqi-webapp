<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chinese Chess (Xiangqi)</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{background:#f4f4f4;font-family:Arial,Helvetica,sans-serif;color:#222;text-align:center}
  h1{color:#b22222;margin:16px 0 6px}
  #turn{color:#666;margin-bottom:12px;font-size:14px}

  /* Khung giữ tỉ lệ 9:10 */
  .board-wrap{
    width:min(92vw, 720px);
    aspect-ratio: 9/10;
    margin:0 auto 32px;
    position:relative;
  }
  canvas#board{position:absolute;inset:0;width:100%;height:100%}

  /* Quân cờ */
  .piece{
    position:absolute;width:52px;height:52px;transform:translate(-50%,-50%);
    border-radius:50%;background:#fff;display:flex;align-items:center;justify-content:center;
    font-weight:700;font-size:22px;user-select:none;cursor:pointer;z-index:5
  }
  .red{color:#d32f2f;border:3px solid #d32f2f}
  .black{color:#000;border:3px solid #000}
  .sel{outline:3px solid #ffd54f;outline-offset:2px;box-shadow:0 0 8px rgba(0,0,0,.25) inset}

  /* Tự co kích thước quân theo CELL tính được */
  .piece[data-cell]{ width:calc(var(--cell-px) - 8px); height:calc(var(--cell-px) - 8px); font-size:calc(var(--cell-px) * .38) }
</style>
</head>
<body>
  <h1>Chinese Chess (Xiangqi)</h1>
  <div id="turn">Red to move</div>

  <div class="board-wrap">
    <canvas id="board"></canvas>
  </div>

<script>
(function(){
  // ========= CẤU HÌNH =========
  const wrap = document.querySelector('.board-wrap');
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const turnEl = document.getElementById('turn');

  // 9 cột (files 0..8), 10 hàng (ranks 0..9)
  const COLS = 9, ROWS = 10;
  let CELL = 60; // sẽ tính động theo kích thước thật
  let turn = 'red';
  const pieces = [];
  const pos = new Map(); // key "c,r" -> piece

  const key = (c,r) => `${c},${r}`;
  const toPx = (c,r) => ({ x: c*CELL + .5, y: r*CELL + .5 });

  function setCanvasSize(){
    const w = wrap.clientWidth;
    const h = wrap.clientHeight;
    canvas.width = Math.round(w);
    canvas.height = Math.round(h);
    // CELL là khoảng cách giữa các điểm giao
    CELL = Math.min(Math.round(canvas.width / COLS), Math.round(canvas.height / ROWS));
    // cập nhật CSS variable để scale quân
    document.documentElement.style.setProperty('--cell-px', CELL + 'px');
    drawBoard();
    placeAll();
  }

  function drawBoard(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#5e3416';
    // nền
    ctx.fillStyle = '#f3c78b';
    ctx.fillRect(0,0, CELL*COLS, CELL*ROWS);

    // HORIZONTALS (y=0..9)
    for(let r=0;r<=9;r++){
      ctx.beginPath();
      ctx.moveTo(0.5, r*CELL + .5);
      ctx.lineTo(CELL*COLS - .5, r*CELL + .5);
      ctx.stroke();
    }

    // VERTICALS (x=0..8), có tách sông ở x=1..7
    for(let c=0;c<=8;c++){
      ctx.beginPath();
      ctx.moveTo(c*CELL + .5, 0.5);
      if(c===0 || c===8){
        // cột ngoài chạy liền mạch
        ctx.lineTo(c*CELL + .5, CELL*ROWS - .5);
      }else{
        // trên sông
        ctx.lineTo(c*CELL + .5, 4*CELL + .5);
        ctx.moveTo(c*CELL + .5, 5*CELL + .5);
        // dưới sông
        ctx.lineTo(c*CELL + .5, CELL*ROWS - .5);
      }
      ctx.stroke();
    }

    // SÔNG
    ctx.fillStyle = '#e0a458';
    ctx.fillRect(0.5, 4*CELL + .5, CELL*COLS - 1, CELL - 1);
    // Chữ
    ctx.fillStyle = '#5c3717';
    ctx.font = `${Math.round(CELL*.6)}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('楚河', 3*CELL, 4.5*CELL);
    ctx.fillText('漢界', 6*CELL, 4.5*CELL);

    // Chéo cung (trên & dưới) 3×3
    // Trên (cột 3..5, hàng 0..2)
    drawDiag(3,0);
    // Dưới (cột 3..5, hàng 7..9)
    drawDiag(3,7);

    function drawDiag(c0,r0){
      const a = toPx(c0, r0), b = toPx(c0+2, r0+2);
      const c = toPx(c0+2, r0), d = toPx(c0, r0+2);
      ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(c.x, c.y); ctx.lineTo(d.x, d.y); ctx.stroke();
    }

    // viền
    ctx.lineWidth = 2;
    ctx.strokeRect(0.5,0.5, CELL*COLS-1, CELL*ROWS-1);
  }

  // ======== QUÂN CỜ & BỐ TRÍ ========
  function addPiece(txt,color,c,r){
    const el = document.createElement('div');
    el.className = `piece ${color}`;
    el.textContent = txt;
    el.dataset.color = color;
    el.dataset.c = c;
    el.dataset.r = r;
    el.setAttribute('data-cell','1'); // để scale theo --cell-px
    wrap.appendChild(el);
    pieces.push(el);
    pos.set(key(c,r), el);
    moveToPixel(el, c, r);
    el.addEventListener('click', onClickPiece);
  }

  function moveToPixel(el,c,r){
    const {x,y} = toPx(c,r);
    el.style.left = (wrap.offsetLeft + x) + 'px'; // nhưng wrap là relative → dùng offset trong wrap
    // Vì .piece là absolutely positioned vào .board-wrap (relative), ta chỉ cần tọa độ local:
    el.style.left = x + 'px';
    el.style.top  = y + 'px';
    el.dataset.c = c; el.dataset.r = r;
  }

  function placeAll(){
    // xóa & đặt lại top/left theo CELL mới
    pieces.forEach(el => moveToPixel(el, +el.dataset.c, +el.dataset.r));
  }

  // Khởi tạo 32 quân
  function setupPieces(){
    // Đen (trên)
    '车马象士将士象马车'.split('').forEach((t,i)=> addPiece(t,'black', i, 0));
    addPiece('炮','black',1,2); addPiece('炮','black',7,2);
    [0,2,4,6,8].forEach(c=> addPiece('卒','black',c,3));
    // Đỏ (dưới)
    '车马相仕帅仕相马车'.split('').forEach((t,i)=> addPiece(t,'red', i, 9));
    addPiece('炮','red',1,7); addPiece('炮','red',7,7);
    [0,2,4,6,8].forEach(c=> addPiece('兵','red',c,6));
  }

  // ======== TƯƠNG TÁC (kéo – thả đơn giản, chưa kiểm luật) ========
  let selected = null;
  function onClickPiece(e){
    const el = e.currentTarget;
    if(selected && selected !== el){
      // khác màu → ăn
      if(selected.dataset.color !== el.dataset.color){
        tryMoveTo(+el.dataset.c, +el.dataset.r);
      }else{
        // cùng màu → đổi chọn
        selected.classList.remove('sel');
        selected = el;
        selected.classList.add('sel');
      }
      return;
    }
    // chọn / bỏ chọn
    if(el.dataset.color !== turn) return; // tới lượt đối phương thì không chọn
    if(selected === el){ el.classList.remove('sel'); selected=null; return; }
    if(selected) selected.classList.remove('sel');
    selected = el; selected.classList.add('sel');
  }

  // click trống để đi tới ô đó
  wrap.addEventListener('click', (e)=>{
    if(!selected) return;
    if(e.target.classList.contains('piece')) return;
    const rect = canvas.getBoundingClientRect();
    const cx = Math.round((e.clientX - rect.left - .5)/CELL);
    const cy = Math.round((e.clientY - rect.top  - .5)/CELL);
    if(cx<0||cx>8||cy<0||cy>9) return;
    if(pos.get(key(cx,cy))) return; // đã có quân
    tryMoveTo(cx,cy);
  });

  function tryMoveTo(c,r){
    // Chưa kiểm tra luật: chỉ di chuyển/ăn cơ bản
    const oc = +selected.dataset.c, or = +selected.dataset.r;
    pos.delete(key(oc,or));

    const victim = pos.get(key(c,r));
    if(victim){
      victim.remove();
      pieces.splice(pieces.indexOf(victim),1);
      pos.delete(key(c,r));
    }

    moveToPixel(selected,c,r);
    pos.set(key(c,r), selected);
    selected.classList.remove('sel');
    selected = null;

    turn = (turn==='red' ? 'black' : 'red');
    turnEl.textContent = (turn==='red'?'Red':'Black') + ' to move';
  }

  // ======== BOOTSTRAP ========
  setupPieces();
  // resize + vẽ
  const ro = new ResizeObserver(setCanvasSize);
  ro.observe(wrap);
  window.addEventListener('orientationchange', setCanvasSize);
  setCanvasSize();
})();
</script>
</body>
</html>
